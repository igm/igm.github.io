<!doctype html><html lang=en><head><meta charset=utf-8><link rel=stylesheet type=text/css media=screen href=//cdnjs.cloudflare.com/ajax/libs/fancybox/1.3.4/jquery.fancybox-1.3.4.css><link rel=stylesheet href=https://igormihalik.com/css/page.css><title>SockJS for Go</title></head><body><div class=content><h1>SockJS for Go</h1><script id=dsq-count-scr src=//igormihalik.disqus.com/count.js async></script><p>SockJS is a browser JavaScript library that provides a WebSocket-like object. SockJS gives you a coherent, cross-browser, Javascript API which creates a low latency, full duplex, cross-domain communication channel between the browser and the web server. Under the hood SockJS tries to use native WebSockets first. If that fails it can use a variety of browser-specific transport protocols and presents them through WebSocket-like abstractions.</p><p>SockJS is intended to work for all modern browsers and in environments which don&rsquo;t support WebSocket protcol, for example behind restrictive corporate proxies. What I was missing was a server side support library for GO programing language. So I decided to create one myself. The protocol itself is not difficult to understand. It tries to simulate websocket functionality. From the JavaScript client the server needs to be able to receive frames represented in JSON format.</p><pre><code>&quot;hello world&quot;
{&quot;name&quot;:&quot;john&quot;,&quot;surname&quot;:&quot;doe&quot;}
</code></pre><p>According to the protocol specification these messages are sent in an array:</p><pre><code>[&quot;hello world&quot;]
[{&quot;name&quot;:&quot;john&quot;,&quot;surname&quot;:&quot;doe&quot;}]
</code></pre><p>And on the other side server needs to be able to send back control frames (heartbeat, open frame, close frame) and data frames, also in JSON format. The supported transport protocols for sending messages to the client can be divided into two groups:</p><ul><li>Streaming: XHR streaming, EventSource, Websocket</li><li>Non streaming: XHR polling, JSONP</li></ul><p>In terms of receiving messages, there are 3 methods: XHR, JSONP and Websocket.
On top of that IFrame and HtmlFile technique is used to overcome various browser specific limitations in order to support transport protocols mentioned above. The SockJS project comes with a convenient set of protocol tests that guarantee the correctness of server side implementation to a certain degree.</p><h2 id=channels-and-locks>Channels and Locks</h2><p>All of the protocols define a certain state of communication. Open state when a connection is established for the first time, then there&rsquo;s a passive state representing existing connection but client is currently disconnected (non streaming protocols) and then the active state when a connection between client and server exists and is active. The last state is connection closed meaning client or server closed the connection and after a certain period of time the connection expires completely and is deleted which is a terminal state. I will not go much into details of protocol specification, rather I&rsquo;ll focus on two problems I faced and how Go language features helped to solve them.</p><h2 id=parallel-requests-from-client>Parallel Requests from Client</h2><p>At any time if a connection is in active state, all other connection requests should be rejected with a close message</p><p>The idiomatic solution in other programming languages is to use a flag associated with a connection and each time a connection gets into active state set the flag and reject all other connections. Using Go I opted for a different approach - Go routines and channels, and it turned out to be an efficient one. The main inspiration came from Rob Pike&rsquo;s presentation Lexical Scanning in Go - Rob Pike. The presentation shows how to implement a state machine using function types, so I defined a function type as follows:</p><pre><code>type connectionStateFn func(*conn) connectionStateFn
</code></pre><p>State is a function, which using a connection as an input parameter performs required logic on connection object (reads HTTP transaction request/response objects) and returns back another state function for further connection processing until it finishes. And the actual execution happens in a separate Go routine.</p><p>Then all the requests that come to the http handler are put into a connection specific input channel and processed sequentially in a concurrent safe way. The state function for open connection looks for example like this:</p><h2 id=concurrent-safe-data-structure-of-connections>Concurrent Safe Data Structure of Connections</h2><p>Another problem that arose was related to a &ldquo;global&rdquo; data structure holding all the connections associated to session id in a map. Data structures in Go are not concurrent safe by default and there&rsquo;s a reason for that. They are just simple and effective low level components to be used to built up more complex structures and they serve that purpose very well. The word &ldquo;global&rdquo; is very important here. Any data not private to a go routine and accessible from several go routines need to be protected. Again, there are two options here: locks or channels. Let&rsquo;s look at both approaches and compare them.</p><h3 id=locks>Locks</h3><p>The concurrent safe code using locks looks like this:</p><h3 id=channels>Channels</h3><p>&ldquo;Don&rsquo;t communicate by sharing memory; share memory by communicating." Let&rsquo;s look at the implementation using channels. Instead of using Lock, we&rsquo;ll create a channel of functions that will be executed in a Go routine specific to the structure:</p><p>Here I&rsquo;m not trying to persuade to use channels instead of locks. Instead on these simple examples with map I want to describe an approach using a channel. Instead of looking at the structure as a data, we can look at it as a micro system (with its own life) that accepts inputs through channel. In case of more complex structures and operations that can be performed on them the implementation might turn out to be easier to understand and implement compared to lock-based approach.</p><h2 id=references>References</h2><ol><li>GoLang Tutorials</li><li>The Go Programming Language</li><li>Lexical Scanning in Go - Rob Pike</li></ol><div id=disqus_thread></div><script>var disqus_config=function(){this.page.url="https://blog.igormihalik.com",this.page.identifier="/post/sockjs-for-go/"};(function(){var a=document,b=a.createElement('script');b.src='//igormihalik.disqus.com/embed.js',b.setAttribute('data-timestamp',+new Date),(a.head||a.body).appendChild(b)})()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript></div><script type=text/javascript src=//code.jquery.com/jquery-1.11.0.min.js></script><script type=text/javascript src=//code.jquery.com/jquery-migrate-1.2.1.min.js></script><script type=text/javascript src=//cdnjs.cloudflare.com/ajax/libs/fancybox/1.3.4/jquery.fancybox-1.3.4.pack.min.js></script><script type=text/javascript>$(function(a){var b=!1,c=!0,d='inside';a(b?'img':'img.fancybox').each(function(){var b=a(this),c=b.attr('title'),d=b.attr('data-big')||b.attr('src'),e=a('<a href="#" class="fancybox"></a>').attr('href',d).attr('title',c);b.wrap(e)}),c&&a('a.fancybox').attr('rel','fancyboxgallery'),a('a.fancybox').fancybox({titlePosition:d})}),$.noConflict()</script></body></html>